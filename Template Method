Призначення
Визначає кістяк[en] алгоритму та дозволяє підкласам перевизначити деякі кроки алгоритму, не змінюючи структуру в цілому.

Застосовність
Слід використовувати шаблон Шаблонний метод коли:

треба одноразово використати інваріантні частини алгоритму, залишаючи реалізацію поведінки, що змінюється, на розсуд підкласів;
треба відокремити та локалізувати в одному класі поведінку, що є загальною для усіх підкласів, щоб запобігти дублювання коду. Це хороший приклад техніки «винесення за лапки з метою узагальнення», що описана в роботі Вільяма Опдайка (англ. William Opdyke) та Ральфа Джонсона (англ. Ralph Johnson) [JO93,OJ93]. Спочатку ідентифікуються відмінності в існуючому коді, а потім вони виносяться у окремі операції. У кінцевому підсумку відмінні фрагменти коду замінюються шаблонним методом, з котрого викликаються нові операції;
для управління розширеннями підкласів. Можна визначити шаблонний метод таким чином, що він буде викликати операції-зачіпки у означених точках, дозволивши тим самим розширення тільки у цих точках.

Переваги та недоліки
Переваги
Немає копіювання коду.
Лише кілька методів потрібно перевизначити.
Гнучкість дозволяє підкласам вирішити, як здійснювати кроки в алгоритмі.
Недоліки
Налагодження та розуміння послідовності алгоритму може іноді бути складною.
Підтримка структури шаблонів може бути проблемою, оскільки зміни на будь-якому рівні (низький рівень або високий рівень) можуть перешкоджати реалізації.

#include <iostream>

using namespace std;

class ApplicationFramework
{
protected:
	// кроки алгоритму перевизначатимуться в похідних класах
	virtual void custom1() = 0;
	virtual void custom2() = 0;
public:
	// сам алгоритм незмінний
	void templateMethod(int n = 1)
	{
		for (int i = 0; i< n; ++i)
		{
			custom1();
			custom2();
		}
	}
};
class MyAppl : public ApplicationFramework
{
protected:
	void custom1() { cout << " Hello, "; }
	void custom2() { cout << " World!\n"; }
};
class CalcAppl : public ApplicationFramework
{
protected:
	void custom1()
	{
		cout << " Results of important calculations are : \n";
	}
	void custom2()
	{
		cout << " 2 + 2 = " << 2 + 2 << " \t2x2 = " << 2 * 2 << '\n';
	}
};
void main()
{
	MyAppl app;
	app.templateMethod(3);
	CalcAppl cApp;
	cApp.templateMethod();
}
